Introduction to R: Exploring the genes of the human genome
=============================================================

Author: John Blischak

## Description

In this lesson we will learn about the basics of R by inspecting a 
biological dataset. I have created a spreadsheet-like dataset using data on
the human genome from the Ensembl Biomart database. Each row contains the
Ensembl transcript that has the longest coding sequence for a given Ensembl
gene ID. I also removed any genes that were not translated at all in order to
keep the size of the dataset manageable. For the exact details, you can see
`data/create_datasets.R`.

My goal is twofold. First is for you to become comfortable with the basics of
R and get some intuition for how it works. Second I want to provide you the
motivation to actually use R the next time you analyze data instead of using
Excel by showing you how powerful it can be. Please ask a question directly to
me or on the EtherPad if you need more explanation.

**Learning objectives:**
+ Understand the various mode of vectors
+ Inspect objects
+ Filter vectors and data frames
+ Use vectorized functions
+ Make basic plots

## Preparing the workspace

As a first step, let's clear out the working environment and verify that
we are in the correct working directory. We'll use the trick we learned in the
first section, `rm(list = ls())` to ensure that there are no objects in the 
working space that could potentially interfere with our analysis if we 
accidentally referred to them. The other option would be to go to the `Session`
tab and click the option `Restart R`.

```{r}
rm(list = ls())
getwd()
```

### Exercise: Set the working directory

```{r}
# Your code here
setwd('/Users/smckay/2014-05-12-cshl/11-11-introtoR')
```

## Import and inspect the dataset

Instead of opening the file in Excel, we use R's `read.table` function. 

```{r}
genes <- read.table("data/ensembl_human_genes.txt", header = TRUE, sep = "\t",
                    quote = "", stringsAsFactors = FALSE)
head
```

We have provided R the following information to retrieve our dataset:
+ Open the file `data/ensembl_human_genes.txt`
+ The file has a header, so the first row contains the column names
+ The file is tab-separated (`"\t"` stands for "tab")
+ Ignore all quotation marks (" and ')
+ Do not convert strings to factors (explanined later in this lesson)

The function `head` gave us a preview of the dataset, which does look very
much like a spreadsheet. There are column names like `ensembl_transcript_id`
and `chromosome_name`, and there are row numbers for each gene entry. 

But how is R representing the data? Let's use some R function to further
inspect this dataset. As we explore what we have imported, we'll learn about 
the different data types in R.

```{r}
class(genes)
dim(genes)
str(genes)
```


Thus, the data is in a data.frame with 21,056 rows and 11 columns. The 11
columns each contain a different type of information, which is summarized by
the function `str`, which shows the **str**ucture of an object. `str` is an
amazing tool for both beginner and advanced programmers (it was voted the
most useful R trick on a [StackOverflow post](http://stackoverflow.com/questions/1295955/what-is-the-most-useful-r-trick)),
so use it often! For our data.frame `genes`, it explains the data in each
column. The individual columns are each a specific type of vector.

## The vector

One big difference between R and other programming languages you may be 
familiar with like C++, Java, Python, Perl, etc. is that there are no scalar
data types. In other words, the base object is a vector. The code below 
demonstrates that even though a variable may look like a scalar, it is 
actually a vector with a length of one. We will see the ramifications of this
soon.

```{r}
x <- 3
is.vector(x)
length(x)
```

A discussion of data types can be an extremely advanced topic. As a 
pragmatic consideration, I will present a **simplified** view of the main types
of vectors in R. Below I will describe four types of vectors:
+ numeric
+ character
+ factor
+ logical

## Numeric vector

A numeric vector in our dataset is `percentage_gc_content`, which as the name
implies is the percentage of G and C bases in the transcript sequence. As the 
output from `str(genes)` hinted, we can access the columns of a data.frame
using the dollar sign character, `$`. Let's learn more about what it contains:

```{r}
is.numeric(genes$percentage_gc_content)
head(genes$percentage_gc_content)
summary(genes$percentage_gc_content)
```

Note that R has designated some vectors as int for integers. In our simplified
view, we are not going to worry about this distintion because R considers
them to be numeric as well, e.g.:

```{r}
is.numeric(genes$cds_length)
```

Since R is designed for exploratory data analysis, it is very simple to 
visualize data.

```{r}
plot(genes$percentage_gc_content)
str(genes$percentage_gc_content)

```

The graph generated by `plot` is not very informative in this case since the
x-axis is simply the order of the data in the vector, i.e. the index, and
also the plot is extremely over-plotted. 

```{r}
hist(genes$percentage_gc_content)
```

On the other hand, the histogram created by `hist` provides a nice
visualization of the information returned by the `summary` function.

R has the typical mathematical functions you would expect:
+ `+`, `-`  addition, subtraction
+ `*`, `/`  multiplication, division
+ `^`  exponentiation
+ `%/%`  integer division
+ `%%`  modulo (returns the remainder of a division operation)

But first, let's create some toy vectors that are more manageable to work with.
There are multiple ways to create a numeric vector. 

```{r}
(num_vec_one <- c(1, 5, 8, 3))  # c stands for "combine"
(num_vec_two <- 1:8)
(num_vec_three <- seq(from = 3, to = 12, by = 3))
```

**Note**: I used a trick above. Normally for an assignment, R generates no
output. In order to see what is contained in the variable as it is assigned,
you can surround the expression with parentheses.

In other programming languages, in order to do something simple like add one to
each number of a vector, you would have to use some sort of looping
mechanism to add each number separately. However, because R is vector-based
this is extremely simple.

```{r}
num_vec_one + 1
num_vec_two / num_vec_three
num_vec_three / num_vec_three
c(0, 0, 0, 0) + 1:3  # alternatively could have used rep(0, 4)
```

The examples above demonstrate the comcept of **recycling**. The first element
of the first vector is paired with the first element of the second, and then
the second elements of each vector, and so on. If one vector is shorter than
than the other, it starts again at the beginning of the vector. As we saw in 
the last example, if the shorter vector is not a multiple of the longer 
vector, R issues a warning since it is likely a mistake.

As you may have deduced, many R functions are "vectorized."

```{r}
sqrt(c(2, 4, 9, 16))
abs(c(-4, 6, -987))
```

Utilizing vectorized functions will not only make your code easier to
understand, but it also will speed up your code. This is because many
base R functions are actually written in C, so one function call to a C
function is much faster than multiple calls to C and/or R functions (see
this blog [post](http://yihui.name/en/2010/10/on-the-gory-loops-in-r/)) for
details).

Lastly, you may have noticed that there is always a "[1]" next to the output.
This tells us the index of the first element on the line. It is useful when
the output spans more than one line, e.g.

```{r}
1:100
```

This also implies that R indexing starts at 1, instead of at 0 like most other
programming languages. We can use this index information to extract specific
elements of a vector.

```{r}
num_vec_three
num_vec_three[2:4]
num_vec_three[c(1, 4)]
genes$external_gene_id[c(1, 4, 15)]
```

**Exercise**

The column `cds_length` contains the number of base pairs that constitute
the protein-coding portion of the gene. Thus, we would expect each entry to
be a multiple of three base pairs. Check to see if our assumption is
correct.

```{r}
# your code here

```



